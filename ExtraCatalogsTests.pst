<?xml version="1.0"?><st-source><!-- Name: ExtraCatalogsTestsNotice: The MIT License (MIT)Copyright (c) 2013 Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copy ofthis software and associated documentation files (the "Software"), to deal inthe Software without restriction, including without limitation the rights touse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies ofthe Software, and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESSFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS ORCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHERIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR INCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: ExtraCatalogs is licensed under the MIT license.  See the Copyrighttab in the RB, the 'notice' property of this package, or the LICENSEfile on GitHub.This package contains the unit tests for ExtraCatalogs.  See that package's comment for more information.DbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1664DbUsername: randyDbVersion: 18DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'ExtraCatalogs' '') #(#any 'SUnitToo' ''))PackageName: ExtraCatalogsTestsParcel: #('ExtraCatalogsTests')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'ExtraCatalogs') #(#name 'SUnitToo'))PrerequisiteParcels: #(#('Base VisualWorks' '') #('ExtraCatalogs' '') #('SUnitToo' ''))PrintStringCache: (18,randy)Version: 18Date: 6:45:12 AM August 2, 2013 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 7.9.1 of October 18, 2012 on August 2, 2013 at 6:45:12 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TranslationUnitTest</name><environment>ExtraCatalogs</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ExtraCatalogsTests</package></attributes></class><class><name>SimpleMessageCatalogTest</name><environment>ExtraCatalogs</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>secondLocale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ExtraCatalogsTests</package></attributes></class><class><name>CatalogRegistryTest</name><environment>ExtraCatalogs</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry secondLocale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ExtraCatalogsTests</package></attributes></class><methods><class-id>ExtraCatalogs.TranslationUnitTest</class-id> <category>tests</category><body package="ExtraCatalogsTests">testEquality	| a |	a := (TranslationUnit id: #a untranslated: 'untran' translated: 'transl')				state: 'state';				catalogID: 'cat';				yourself.	self assert: a = a copy</body><body package="ExtraCatalogsTests">testInEquality	| a b |	a := (TranslationUnit id: #a untranslated: 'untran' translated: 'transl')				state: 'state';				catalogID: 'cat';				yourself.	b := (TranslationUnit id: #b untranslated: 'untran' translated: 'transl')				state: 'state';				catalogID: 'cat';				yourself.	self assert: a ~= b</body><body package="ExtraCatalogsTests">testUserMessageAsTranslationUnit	| translationUnit |	translationUnit := (#test &gt;&gt; 'Value' &lt;&lt; 'DE') asTranslationUnit.	self		assert: translationUnit id == #test;		assert: translationUnit untranslated = 'Value';		assert: translationUnit translated = 'Value';		assert: translationUnit state = 'needs-translation';		assert: translationUnit catalogID = 'DE'</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalogTest</class-id> <category>tests</category><body package="ExtraCatalogsTests">testAdditions	| catalog1 catalog2 additions |	catalog1 := SimpleMessageCatalog new.	catalog1 add: #a &gt;&gt; 'a1'.	catalog1 add: #b &gt;&gt; 'b2'.	catalog1 add: #F &gt;&gt; 'F1'.	catalog2 := SimpleMessageCatalog new.	catalog2 add: #a &gt;&gt; 'a1'.	catalog2 add: #c &gt;&gt; 'c3'.	catalog2 add: #F &gt;&gt; 'F2'.	additions := catalog1 additions: catalog2.	self assert: additions count = 1.	self assert: (additions lookUp: #c &gt;&gt; 'z') = 'c3'</body><body package="ExtraCatalogsTests">testCatalogCreation	| result |	result := SimpleMessageCatalog id: 'ID'.	self assert: (result isKindOf: SimpleMessageCatalog).	self assert: result map isEmpty.	self assert: result id = #ID</body><body package="ExtraCatalogsTests">testCatalogScopedCantLookup	| string |	self setupSampleCatalogs.	string := SimpleMessageCatalog lookUp: #token2 &gt;&gt; 'Not translated' &lt;&lt; #one.	self assert: string isNil.	string := SimpleMessageCatalog lookUp: #token2 &gt;&gt; 'Not translated' &lt;&lt; #two.	self assert: string = '123'</body><body package="ExtraCatalogsTests">testCatalogScopedLookup	| string |	self setupSampleCatalogs.	string := SimpleMessageCatalog lookUp: #token1 &gt;&gt; 'Not translated' &lt;&lt; #one.	self assert: string = 'ABC'.	string := SimpleMessageCatalog lookUp: #token1 &gt;&gt; 'Not translated' &lt;&lt; #two.	self assert: string = 'XYZ'</body><body package="ExtraCatalogsTests">testConflicts	| catalog1 catalog2 conflicts |	catalog1 := SimpleMessageCatalog new.	catalog1 add: #a &gt;&gt; 'a1'.	catalog1 add: #b &gt;&gt; 'b2'.	catalog1 add: #F &gt;&gt; 'F1'.	catalog2 := SimpleMessageCatalog new.	catalog2 add: #a &gt;&gt; 'a1'.	catalog2 add: #c &gt;&gt; 'c3'.	catalog2 add: #F &gt;&gt; 'F2'.	conflicts := catalog1 conflicts: catalog2.	self assert: conflicts count = 1.	self assert: (conflicts lookUp: #F &gt;&gt; 'F3') = 'F2'</body><body package="ExtraCatalogsTests">testEquality	| catalog1 catalog2 catalog3 |	catalog1 := (SimpleMessageCatalog new)				add: #one &gt;&gt; 'One';				add: #two &gt;&gt; 'Two';				yourself.	catalog2 := (SimpleMessageCatalog new)				add: #One &gt;&gt; 'One';				add: #Two &gt;&gt; 'Two';				yourself.	self deny: catalog1 = catalog2.	catalog3 := (SimpleMessageCatalog new)				add: #one &gt;&gt; 'One';				add: #two &gt;&gt; 'Two';				yourself.	self assert: catalog1 = catalog3</body><body package="ExtraCatalogsTests">testID	| catalog |	catalog := SimpleMessageCatalog id: nil.	self assert: catalog id isNil.	catalog := SimpleMessageCatalog id: 'String'.	self assert: catalog id = #String</body><body package="ExtraCatalogsTests">testImportXLIFFFile	| catalog path |	path := 'sample.xliff'.	self writeSampleXLIFFFile: path.	catalog := SimpleMessageCatalog fromXLIFF: path.	self assert: catalog id = #sample.	self assert: (catalog lookUp: #start &gt;&gt; '') = 'nachalo'.	self assert: (catalog lookUp: #middle &gt;&gt; '') = 'sreda'.	self assert: (catalog lookUp: #end &gt;&gt; '') = 'krai'.	path asFilename delete</body><body package="ExtraCatalogsTests">testMarkAllComplete	| catalog |	catalog := SimpleMessageCatalog new.	catalog add: #a &gt;&gt; 'a1'.	catalog add: #b &gt;&gt; 'b2'.	catalog add: #F &gt;&gt; 'F1'.	catalog translationUnitsDo: [:each | self assert: each state = 'needs-translation'].	catalog markAllComplete.	catalog translationUnitsDo: [:each | self assert: each state = 'complete']</body><body package="ExtraCatalogsTests">testMerge	| catalog1 catalog2 |	catalog1 := SimpleMessageCatalog new.	catalog1 add: #a &gt;&gt; 'a1'.	catalog1 add: #b &gt;&gt; 'b2'.	catalog1 add: #F &gt;&gt; 'F1'.	catalog2 := SimpleMessageCatalog new.	catalog2 add: #a &gt;&gt; 'a1'.	catalog2 add: #c &gt;&gt; 'c3'.	catalog2 add: #F &gt;&gt; 'F2'.	self assert: catalog1 count = 3.	catalog1 upgrade: catalog2.	self assert: catalog1 count = 4.	self assert: (catalog1 lookUp: #a &gt;&gt; 'not') = 'a1'.	self assert: (catalog1 lookUp: #b &gt;&gt; 'not') = 'b2'.	self assert: (catalog1 lookUp: #c &gt;&gt; 'not') = 'c3'.	self assert: (catalog1 lookUp: #F &gt;&gt; 'not') = 'F2'</body><body package="ExtraCatalogsTests">testMessageAdding	| catalog |	catalog := SimpleMessageCatalog id: #ID.	self assert: catalog isEmpty.	catalog add: #user &gt;&gt; 'Message'.	self assert: (catalog lookUp: #user &gt;&gt; 'whatever') = 'Message'.	self deny: catalog isEmpty</body><body package="ExtraCatalogsTests">testNoCatalogCantLookup	| string |	self setupSampleCatalogs.	string := SimpleMessageCatalog lookUp: #noToken &gt;&gt; 'Not translated' &lt;&lt; nil.	self assert: string isNil</body><body package="ExtraCatalogsTests">testNoCatalogLookup	| string |	self setupSampleCatalogs.	string := SimpleMessageCatalog lookUp: #token1 &gt;&gt; 'Not translated' &lt;&lt; nil.	self assert: string = 'XYZ'</body><body package="ExtraCatalogsTests">testProcessSpecificLocale		| result |	self setupSampleCatalogs.	Locale current: secondLocale.	result := SimpleMessageCatalog lookUp: #token1 &gt;&gt; 'missed'.	self assert: result isNil.	result := SimpleMessageCatalog lookUp: #token1 &lt;&lt; #one.	self assert: result isNil.	(SimpleMessageCatalog id: #one)		registerWith: secondLocale;		add: #token1 &gt;&gt; 'hit'.	result := SimpleMessageCatalog lookUp: #token1 &lt;&lt; #one.	self assert: result = 'hit'</body><body package="ExtraCatalogsTests">testRemovals	| catalog1 catalog2 removals |	catalog1 := SimpleMessageCatalog new.	catalog1 add: #a &gt;&gt; 'a1'.	catalog1 add: #b &gt;&gt; 'b2'.	catalog1 add: #F &gt;&gt; 'F1'.	catalog2 := SimpleMessageCatalog new.	catalog2 add: #a &gt;&gt; 'a1'.	catalog2 add: #c &gt;&gt; 'c3'.	catalog2 add: #F &gt;&gt; 'F2'.	removals := catalog1 removals: catalog2.	self assert: removals count = 1.	self assert: (removals lookUp: #b &gt;&gt; 'z') = 'b2'</body><body package="ExtraCatalogsTests">testWriteXLIFFFile	| catalog path |	path := 'sample.xliff'.	path asFilename exists ifTrue: [path asFilename delete].	self deny: path asFilename exists.	catalog := SimpleMessageCatalog id: #ID.	catalog add: #token &gt;&gt; 'XLATION'.	catalog writeXLIFFFile: path.	self assert: path asFilename exists.	self assert: path asFilename fileSize &gt; 100.	path asFilename delete</body><body package="ExtraCatalogsTests">testWriteXLIFFToStream	| ws catalog |	ws := String new writeStream.	catalog := SimpleMessageCatalog new id: #ID.	catalog add: #key1 &gt;&gt; 'abc'.	catalog add: #key2 &gt;&gt; 'def'.	catalog writeXLIFFOn: ws as: 'AB-DC'.	self assert: ws contents 				= '&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;xliff version="1.1"&gt;	&lt;file datatype="x-visualworks" original="ignored" source-language="AB-DC"&gt;		&lt;body&gt;			&lt;trans-unit id="key1"&gt;				&lt;source&gt;abc&lt;/source&gt;				&lt;target state="needs-translation"&gt;abc&lt;/target&gt;			&lt;/trans-unit&gt;			&lt;trans-unit id="key2"&gt;				&lt;source&gt;def&lt;/source&gt;				&lt;target state="needs-translation"&gt;def&lt;/target&gt;			&lt;/trans-unit&gt;		&lt;/body&gt;	&lt;/file&gt;&lt;/xliff&gt;'</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalogTest</class-id> <category>private</category><body package="ExtraCatalogsTests">writeSampleXLIFFFile: aPath 	| ws |	ws := (aPath asFilename withEncoding: #UTF16) writeStream.		[ws nextPut: (Character value: 16rFEFF).	ws 		nextPutAll: '&lt;?xml version="1.0"?&gt;&lt;xliff version="1.1"&gt;	&lt;file&gt;		&lt;body&gt;			&lt;trans-unit id="start"&gt;				&lt;source&gt;start&lt;/source&gt;				&lt;target state="needs-translation"&gt;nachalo&lt;/target&gt;			&lt;/trans-unit&gt;			&lt;trans-unit id="middle"&gt;				&lt;source&gt;middle&lt;/source&gt;				&lt;target state="needs-translation"&gt;sreda&lt;/target&gt;			&lt;/trans-unit&gt;			&lt;trans-unit id="end"&gt;				&lt;source&gt;end&lt;/source&gt;				&lt;target state="needs-translation"&gt;krai&lt;/target&gt;			&lt;/trans-unit&gt;		&lt;/body&gt;	&lt;/file&gt;&lt;/xliff&gt;'] 			ensure: [ws close]</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalogTest</class-id> <category>initialize-release</category><body package="ExtraCatalogsTests">setUp	SimpleMessageCatalog initializeRegistry.	secondLocale := Locale		named:			(Locale availableLocales detect: [:each | each ~= Locale current name])</body><body package="ExtraCatalogsTests">setupSampleCatalogs	| cat |	cat := SimpleMessageCatalog id: #one.	cat add: #token1 &gt;&gt; 'ABC'.	cat register.	cat := SimpleMessageCatalog id: #two.	cat add: #token1 &gt;&gt; 'XYZ'.	cat add: #token2 &gt;&gt; '123'.	cat register</body><body package="ExtraCatalogsTests">tearDown		SimpleMessageCatalog initializeRegistry.	Locale current: nil</body></methods><methods><class-id>ExtraCatalogs.CatalogRegistryTest</class-id> <category>tests</category><body package="ExtraCatalogsTests">testAddCatalogForLocale	| catalog |	catalog := SimpleMessageCatalog id: 'ID'.	registry		addCatalog: catalog		forLocale: Locale current.	self assert: registry activeCatalogs = (Array with: catalog).	self		assert:			(registry catalogsForLocale: Locale current) == registry activeCatalogs.	self assert: (registry catalogsForLocale: secondLocale) isEmpty</body><body package="ExtraCatalogsTests">testFlush	| catalog1 catalog2 |	catalog1 := SimpleMessageCatalog id: 'ID'.	catalog2 := SimpleMessageCatalog id: 'ID'.	registry		addCatalog: catalog1			forLocale: Locale current;		addCatalog: catalog2 forLocale: secondLocale.	registry flush.	self assert: registry activeCatalogs isEmpty.	self assert: (registry catalogsForLocale: secondLocale) isEmpty</body><body package="ExtraCatalogsTests">testPerLocaleLookup	| catalog1 catalog2 |	catalog1 := SimpleMessageCatalog id: 'ID'.	catalog2 := SimpleMessageCatalog id: 'ID'.	registry		addCatalog: catalog1			forLocale: Locale current;		addCatalog: catalog2 forLocale: secondLocale.	self assert: registry activeCatalogs = (Array with: catalog1).	Locale current: secondLocale.	self assert: registry activeCatalogs = (Array with: catalog2)</body><body package="ExtraCatalogsTests">testRegisterWithFlushesCatalogsWithSameID	| catalog1 catalog2 |	catalog1 := SimpleMessageCatalog id: 'Test'.	catalog2 := SimpleMessageCatalog id: 'Test'.	registry		addCatalog: catalog1		forLocale: Locale current.	self assert: registry activeCatalogs = (Array with: catalog1).	registry		addCatalog: catalog2		forLocale: Locale current.	self assert: registry activeCatalogs = (Array with: catalog2)</body><body package="ExtraCatalogsTests">testSameNamedLocaleInstances	| catalog |	catalog := SimpleMessageCatalog id: 'ID'.	registry		addCatalog: catalog		forLocale: Locale current.	self		assert:			(registry catalogsForLocale: Locale current copy) = (Array with: catalog)</body></methods><methods><class-id>ExtraCatalogs.CatalogRegistryTest</class-id> <category>initialize-release</category><body package="ExtraCatalogsTests">setUp	registry := CatalogRegistry new.	secondLocale := Locale		named:			(Locale availableLocales detect: [:each | each ~= Locale current name])</body><body package="ExtraCatalogsTests">tearDown	Locale current: nil</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class></st-source>