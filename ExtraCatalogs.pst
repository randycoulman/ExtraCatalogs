<?xml version="1.0"?><st-source><!-- Name: ExtraCatalogsNotice: The MIT License (MIT)Copyright (c) 2013 Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copy ofthis software and associated documentation files (the "Software"), to deal inthe Software without restriction, including without limitation the rights touse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies ofthe Software, and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESSFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS ORCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHERIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR INCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: # ExtraCatalogsAlternative MessageCatalog for Visualworks Smalltalk that supports[XLIFF](http://en.wikipedia.org/wiki/XLIFF)-format files.ExtraCatalogs is licensed under the MIT license.  See the Copyrighttab in the RB, the 'notice' property of this package, or the LICENSEfile on GitHub.ExtraCatalogs' primary home is the[Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).Check there for the latest version.  It is also on[GitHub](https://github.com/randycoulman/ExtraCatalogs).ExtraCatalogs is compatible with VW 7.7 and later.  If you find anyincompatibilities with VW7.7 or later, let me know (see below for contact information) or filean issue on GitHub.# IntroductionExtraCatalogs provides `SimpleMessageCatalog`, an alternative`MessageCatalog` for Visualworks Smalltalk.  A `SimpleMessageCatalog`is an in-memory dictionary of translated strings that works with thenormal translation lookup in Visualworks.  It doesn't replace theexisting system; rather it works alongside it as an alternative methodof resolving `UserMessage`s.ExtraCatalogs consists of three packages:* ExtraCatalogs: The base package containing all you need to use  `SimpleMessageCatalog`s in your application.* ExtraCatalogsTools: Contains `UserMessageExtractor`, a handy tool  for extracting `UserMessage`s from your application in order to  generate an XLIFF file for your translators.* ExtraCatalogsTests: The unit tests for ExtraCatalogs.## Using Simple Message CatalogsAssuming you have one or more XLIFF files containing the translationsfor your application (see below), you can load the XLIFF file into a`SimpleMessageCatalog`:```catalog := SimpleMessageCatalog fromXLIFF: xliffFilename```Once you've loaded a catalog, you then need to register it with aLocale.  You can either register it with the current locale:```catalog register```or with a different locale:```catalog registerWith: anotherLocale```Once the catalog is registered, there is no need for your applicationto retain a reference to it; it is maintained in a registry and willnow participate in `UserMessage` lookup using the normal Visualworksmechanisms.When your application closes, you can release all of the loadedcatalogs by sending:```SimpleMessageCatalog flush```## Generating Simple Message CatalogsWhere do you get an XLIFF file to start with?  Most translationservices work with this format, so it is possible that you can alreadyget one from your translator.If not, `UserMessageExtractor` from ExtraCatalogsTools can providesome rudimentary help.  Using the built-in facilities in Visualworks,iterate all of the methods in your application that might contain`UserMessage`s that need to be translated.One way to do this is to start with `SystemUtils>>allBehaviorsDo:` andfilter the results based on whether the class might contain`UserMessage`s that you care about.For each method:```tree := aCompiledMethod mclass parseTreeFor: aCompiledMethod selector.visitor := UserMessageExtractor new.[visitor visitNode: tree] on: InformationSignal    do: [:ex | "Found a UserMessage that couldn't be extracted"               ex resume].^visitor userMessages```Once you've collected all of the `UserMessage`s, you can write an XLIFFfile containing them:```catalog := (SimpleMessageCatalog id: #myCatalogID)    addAll: collectedUserMessages;    yourself.catalog writeXLIFFFile```This will create a file named `myCatalogID.xliff`.  You can use`writeXLIFFFile:` and provide your own filename if you prefer.Once you have your XLIFF file(s), you can send them to your translatorto be translated.  When you get them back, include them with yourapplication and you're ready to go.## Maintaining Simple Message Catalogs`SimpleMessageCatalog` contains methods that are useful in maintainingmessage catalogs as they evolve over time.* `additions: aCatalog`: Assume `aCatalog` is an updated version of  `self` and answer a new catalog that contains any new  `UserMessage`s.* `removals: aCatalog`: Assume `aCatalog` is an updated version of  `self` and answer a new catalog that contains any removed  `UserMessage`s.* `conflicts: aCatalog`: Assume `aCatalog` is an updated version of  `self` and answer a new catalog that contains any `UserMessage`s  that have conflicting default strings.* `upgrade: aCatalog`: Add or update all `UserMessage`s in `aCatalog`  to `self`.Using these messages, it is possible to generate a new version of acatalog, create a new "delta" catalog containing the additions and conflictsbetween the new catalog and the previous version.  This delta catalogis usually much smaller than the original and can be translated moreinexpensively.  When the translated delta catalog is received backfrom the translator, the new catalog can be upgraded with thetranslated delta catalog.## Understanding the CodeThe two main classes of interest are `SimpleMessageCatalog` and`UserMessageExtractor`.  Start from the class comments of thoseclasses.# ContributingI'm happy to receive bug fixes and improvements to this package.  Ifyou'd like to contribute, please publish your changes as a "branch"(non-integer) version in the Public Store Repository and contact me asoutlined below to let me know.  I will merge your changes back intothe "trunk" as soon as I can review them.# CreditsExtraCatalogs was originally written by Travis Griggs, who hasgraciously allowed me to take over maintenance of this package.# Contact InformationIf you have any questions about this package and how to use it, feel free to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1665DbUsername: randyDbVersion: 44DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' ''))PackageName: ExtraCatalogsParcel: #('ExtraCatalogs')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle))PrerequisiteParcels: #(#('Base VisualWorks' ''))PrintStringCache: (44,randy)Version: 44Date: 6:45:12 AM August 2, 2013 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 7.9.1 of October 18, 2012 on August 2, 2013 at 6:45:12 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ExtraCatalogs</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>ExtraUserMessages</category><attributes><package>ExtraCatalogs</package></attributes></name-space><class><name>CatalogRegistry</name><environment>ExtraCatalogs</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>catalogs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ExtraCatalogs</package></attributes></class><comment><class-id>ExtraCatalogs.CatalogRegistry</class-id><body>A registry of SimpleMessageCatalogs keyed by the Locale they correspond to.Instance Variables	catalogs	&lt;Dictionary&gt; The catalogs, keyed by Locale.</body></comment><class><name>TranslationUnit</name><environment>ExtraCatalogs</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id untranslated translated state catalogID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ExtraCatalogs</category><attributes><package>ExtraCatalogs</package></attributes></class><comment><class-id>ExtraCatalogs.TranslationUnit</class-id><body>Represents a single UserMessage within a SimpleMessageCatalog.  Corresponds to the "trans-unit"element in the XLIFF specification.UserMessages and TranslationUnits can be converted back and forth using #asTranslationUnit and #asUserMessage.  This is a lossy conversion, however, because they don't have exactly the same state.Instance Variables	catalogID	&lt;Symbol&gt;	Identifier of the message catalog to which this TranslationUnit belongs.  Not really used yet.	id	&lt;Symbol&gt;	Identifier of the UserMessage represented by this TranslationUnit.	state	&lt;String&gt;	The state of the translation (see http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html#state for allowable values).	translated	&lt;String&gt;	The translated text of the UserMessage.	untranslated	&lt;String&gt;	The untranslated text of the UserMessage.</body></comment><class><name>SimpleMessageCatalog</name><environment>ExtraCatalogs</environment><super>Kernel.MessageCatalog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>map id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>ExtraCatalogs</package></attributes></class><comment><class-id>ExtraCatalogs.SimpleMessageCatalog</class-id><body>An in-memory MessageCatalog that uses the [XLIFF](http://en.wikipedia.org/wiki/XLIFF) file format for storage.A catalog can be read from an XLIFF file (#fromXLIFF: on the class side) and registered with a Locale (#register / #registerWith:).  It will then participate in the normal Visualworks UserMessage lookup.A catalog can be generated by creating a new, unregistered instance (#id: on the class side), adding UserMessages to it (#add: / #addAll:), and writing it to a file (#writeXLIFFFile / #writeXLIFFFile:).Over time, translations will evolve. The 'differences' protocol has a handful of handy methods which can be used to compare and contrast two catalogs. For example, one could take the result of an old xliff file, generate the up to date one, and then use messages such as conflicts:/additions:/removals: to get the deltas between the two, or possibly upgrade: to combine them.The class side 'registry' protocol has some additional methods for managing registered catalogs.Shared Variables	Catalogs &lt;Dictionary&gt; maps Locales (keys) to collections of catalogsInstance Variables	id	&lt;Symbol&gt;	the name for this catalog. This is optional, is used for matching if both the receiver and the candidate UserMessage have non nil id/messageCatalog set	map	&lt;Dictionary&gt;	maps message ids to the translated strings</body></comment><shared-variable><name>Registry</name><environment>ExtraCatalogs.SimpleMessageCatalog</environment><private>false</private><constant>false</constant><category>registry</category><attributes><package>ExtraCatalogs</package></attributes></shared-variable><methods><class-id>ExtraCatalogs.CatalogRegistry</class-id> <category>accessing</category><body package="ExtraCatalogs">activeCatalogs	"Answer the catalogs that apply to the current Locale."	^self catalogsForLocale: Locale current</body><body package="ExtraCatalogs">catalogsForLocale: aLocale	"Answer the catalogs that apply to aLocale."	^catalogs at: (self keyForLocale: aLocale) ifAbsent: [Array new]</body><body package="ExtraCatalogs">flush	"Remove all catalogs from the registry."	catalogs := Dictionary new</body><body package="ExtraCatalogs">lookUp: aUserMessage	"Look up aUserMessage in the active catalogs.	If a UserMessage key is found in more than one catalog, the most-recently-registered catalog wins.  	This is the main API used by the VisualWorks UserMessage resolution engine. 	It is open coded for speed."	| resolved toSearch |	toSearch := self activeCatalogs.	toSearch size to: 1		by: -1		do: 			[:n |			resolved := (toSearch at: n) lookUp: aUserMessage.			resolved == nil ifFalse: [^resolved]].	^nil</body></methods><methods><class-id>ExtraCatalogs.CatalogRegistry</class-id> <category>private</category><body package="ExtraCatalogs">keyForLocale: aLocale	^aLocale languageID</body></methods><methods><class-id>ExtraCatalogs.CatalogRegistry</class-id> <category>adding</category><body package="ExtraCatalogs">addCatalog: aCatalog forLocale: aLocale	"Register aCatalog for aLocale.  If a catalog with the same ID is already registered,it is replaced by aCatalog.  If a UserMessage key is found in more than one catalog,the most-recently-registered catalog wins."	| original new |	original := self catalogsForLocale: aLocale.	new := (original reject: [:each | each id = aCatalog id])				copyWith: aCatalog.	catalogs at: (self keyForLocale: aLocale) put: new</body></methods><methods><class-id>ExtraCatalogs.CatalogRegistry</class-id> <category>initialize-release</category><body package="ExtraCatalogs">initialize	super initialize.	catalogs := Dictionary new</body></methods><methods><class-id>ExtraCatalogs.CatalogRegistry class</class-id> <category>instance creation</category><body package="ExtraCatalogs">new	^super new initialize</body></methods><methods><class-id>ExtraCatalogs.TranslationUnit</class-id> <category>accessing</category><body package="ExtraCatalogs">catalogID	^catalogID</body><body package="ExtraCatalogs">catalogID: aString	catalogID := aString</body><body package="ExtraCatalogs">id	^id</body><body package="ExtraCatalogs">state	^state</body><body package="ExtraCatalogs">state: aString	state := aString</body><body package="ExtraCatalogs">translated	^translated</body><body package="ExtraCatalogs">translated: aString	translated := aString</body><body package="ExtraCatalogs">untranslated	^untranslated</body></methods><methods><class-id>ExtraCatalogs.TranslationUnit</class-id> <category>comparing</category><body package="ExtraCatalogs">= aTranslationUnit 	^aTranslationUnit class == self class and: 			[aTranslationUnit id = self id and: 					[aTranslationUnit untranslated = self untranslated and: 							[aTranslationUnit translated = self translated 								and: [aTranslationUnit catalogID = self catalogID]]]]</body><body package="ExtraCatalogs">hash	^self id hash + self untranslated hash + self translated hash 		+ self catalogID hash</body></methods><methods><class-id>ExtraCatalogs.TranslationUnit</class-id> <category>converting</category><body package="ExtraCatalogs">asTranslationUnit	^self</body><body package="ExtraCatalogs">asUserMessage	"Convert self to a UserMessage representing the translated message."	^UserMessage defaultString: self translated key: self id asSymbol</body></methods><methods><class-id>ExtraCatalogs.TranslationUnit</class-id> <category>xliff</category><body package="ExtraCatalogs">asXMLElement	"Answer the XLIFF representation of this TranslationUnit."	| source transunit target |	transunit := XML.Element tag: 'trans-unit'.	transunit		attributes: (Array with: (XML.Attribute name: 'id' value: id asString)).	source := XML.Element tag: 'source'.	source addNode: (XML.Text text: untranslated).	transunit addNode: source.	target := XML.Element tag: 'target'.	target		attributes: (Array with: (XML.Attribute name: 'state' value: state)).	target addNode: (XML.Text text: translated).	transunit addNode: target.	^transunit</body></methods><methods><class-id>ExtraCatalogs.TranslationUnit</class-id> <category>initialize-release</category><body package="ExtraCatalogs">initialize	super initialize.	state := 'needs-translation'</body><body package="ExtraCatalogs">setId: aSymbol untranslated: untranslatedString translated: translatedString		id := aSymbol.	untranslated := untranslatedString.	translated := translatedString</body></methods><methods><class-id>ExtraCatalogs.TranslationUnit</class-id> <category>printing</category><body package="ExtraCatalogs">printOn: aWriteStream	aWriteStream		nextPutAll: 'TranslantionUnit: ';		nextPutAll: self id asString;		cr;		tab;		nextPutAll: 'Untranslated: ';		nextPutAll: self untranslated;		cr;		tab;		nextPutAll: 'Translated: ';		nextPutAll: translated;		cr;		tab;		nextPutAll: 'State: ';		nextPutAll: self state;		cr;		tab;		nextPutAll: 'CatalogID:';		nextPutAll: (self catalogID ifNil: [nil printString])</body></methods><methods><class-id>ExtraCatalogs.TranslationUnit class</class-id> <category>instance creation</category><body package="ExtraCatalogs">fromXmlElement: aXmlElement	"Create a new TranslationUnit from its XLIFF representation."	^self		id: (aXmlElement attributes detect: [:att | att key type = 'id']) value				asSymbol		untranslated: (aXmlElement elementNamed: 'source') elements first text		translated: (aXmlElement elementNamed: 'target') elements first text</body><body package="ExtraCatalogs">id: aSymbol untranslated: untranslatedString translated: translatedString	"Create a new TranslationUnit."	^(self new)		setId: aSymbol untranslated: untranslatedString translated: translatedString;		yourself</body><body package="ExtraCatalogs">new	^super new initialize</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog</class-id> <category>accessing</category><body package="ExtraCatalogs">add: aUserMessage	"Add (or replace) aUserMessage to the catalog."	| translationUnit |	translationUnit := aUserMessage asTranslationUnit.	map at: translationUnit id put: translationUnit</body><body package="ExtraCatalogs">addAll: aCollectionOfUserMessages	"Add all of the user messages to the catalog."	aCollectionOfUserMessages do: [:each | self add: each]</body><body package="ExtraCatalogs">catalogID	"Protocol required by MessageCatalogManager"		^self id</body><body package="ExtraCatalogs">count	^map size</body><body package="ExtraCatalogs">id	^id</body><body package="ExtraCatalogs">keys	"Answer the ids of all of the messages in the catalog."	^map keys</body><body package="ExtraCatalogs">lookUp: aUserMessage	"Look up aUserMessage in the catalog, but only if its catalogID matches.  Answer nil if not found."	| translationUnit |	translationUnit := aUserMessage asTranslationUnit.	(translationUnit catalogID notNil and: [translationUnit catalogID ~= id])		ifTrue: [^nil].	map at: translationUnit id ifPresent: [:value | ^value translated].	^nil</body><body package="ExtraCatalogs">markAllComplete	"Mark all of the messages in the catalog as complete."	self translationUnitsDo: [:each | each state: 'complete']</body><body package="ExtraCatalogs">remove: aUserMessage	"Remove aUserMessage from the catalog, if present."	map removeKey: aUserMessage key ifAbsent: []</body><body package="ExtraCatalogs">translationUnitsDo: aBlock	"Evaluate a block for each entry in the catalog."	map do: [:each | aBlock value: each]</body><body package="ExtraCatalogs">values	"Answer all of the translation units in the catalog."	^map values</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog</class-id> <category>xliff</category><body package="ExtraCatalogs">writeXLIFFFile	"Write the catalog to an XLIFF file named after the catalogID."	self writeXLIFFFile: id , '.xliff'</body><body package="ExtraCatalogs">writeXLIFFFile: aPath	"Write the catalog to an XLIFF file named aPath."	| fn ws |	fn := aPath asFilename.	ws := (fn withEncoding: #UTF8) writeStream.	[self writeXLIFFOn: ws] ensure: [ws close]</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog</class-id> <category>testing</category><body package="ExtraCatalogs">isEmpty	^map isEmpty</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog</class-id> <category>differences</category><body package="ExtraCatalogs">additions: aCatalog	"Return a copy of me which contains any items which are present in aCatalog, but not in me, as if aCatalog were an evolution of the receiver and these were the items that had been added."	^aCatalog removals: self</body><body package="ExtraCatalogs">conflicts: aCatalog	"Return a copy of aCatalog which contains only the items have conflicting translations from myself."	| conflicts |	conflicts := self class id: id.	aCatalog		translationUnitsDo:			[:each | 			(self lookUp: each)				ifNotNil:					[:myString | myString = each translated ifFalse: [conflicts add: each]]].	^conflicts</body><body package="ExtraCatalogs">removals: aCatalog 	"Return a copy of me which contains any items which are present in me, but not in aCatalog, as if aCatalog were an evolution of the receiver and these were the items that had been removed."	| removals |	removals := self class id: id.	self 		translationUnitsDo: [:each | (aCatalog lookUp: each) ifNil: [removals add: each]].	^removals</body><body package="ExtraCatalogs">upgrade: aCatalog	"Treat aCatalog as if it were a list of the items that needed to be updated/added to me."	aCatalog translationUnitsDo: [:each | self add: each]</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog</class-id> <category>comparing</category><body package="ExtraCatalogs">= aMessageCatalog		^self class = aMessageCatalog class		and:			[id = aMessageCatalog id and: [map contentsEquals: aMessageCatalog map]]</body><body package="ExtraCatalogs">hash	^self map hash bitXor: id hash</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog</class-id> <category>initialize-release</category><body package="ExtraCatalogs">id: anObject	id := anObject ifNotNil: [anObject asSymbol]</body><body package="ExtraCatalogs">initialize	super initialize.	map := Dictionary new</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog</class-id> <category>registration</category><body package="ExtraCatalogs">register	"Register the catalog with the current Locale."	self registerWith: Locale current</body><body package="ExtraCatalogs">registerWith: aLocale	"Register the catalog with aLocale."	self class registerCatalog: self forLocale: aLocale</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog</class-id> <category>private</category><body package="ExtraCatalogs">importXLIFFFile: aPath 	| xliff |	xliff := self xliffFrom: aPath.	(xliff elementsNamed: 'file') do: 			[:file | 			((file elementNamed: 'body') elementsNamed: 'trans-unit') 				do: [:unit | self add: (TranslationUnit fromXmlElement: unit)]]</body><body package="ExtraCatalogs">map	^map</body><body package="ExtraCatalogs">writeXLIFFOn: aStream 	^self writeXLIFFOn: aStream as: 'EN-US'</body><body package="ExtraCatalogs">writeXLIFFOn: aStream as: aLanguageCode		| doc xml xliff file |	doc := XML.Document new.	xml := XML.PI name: 'xml' text: 'version="1.0" encoding="utf-8"'.	doc addNode: xml.	xliff := XML.Element tag: 'xliff'.	xliff		attributes: (Array with: (XML.Attribute name: 'version' value: '1.1')).	file := XML.Element tag: 'file'.	file		attributes:			(Array				with: (XML.Attribute name: 'original' value: 'ignored')				with: (XML.Attribute name: 'source-language' value: aLanguageCode)				with: (XML.Attribute name: 'datatype' value: 'x-visualworks')).	file addNode: self xliffBodyElement.	xliff addNode: file.	doc addNode: xliff.	doc printOn: aStream</body><body package="ExtraCatalogs">xliffBodyElement		| body |	body := XML.Element tag: 'body'.	map keys asSortedCollection		do: [:each | body addNode: (map at: each) asXMLElement].	^body</body><body package="ExtraCatalogs">xliffFrom: aStringPath 	| contents parser |	contents := XML.XMLParser readFileContents: aStringPath asFilename.	parser := XML.XMLParser on: contents readStream.	parser validate: false.	parser scanDocument.	^parser document children last</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog class</class-id> <category>instance creation</category><body package="ExtraCatalogs">fromXLIFF: aPath	"Recover a catalog from its XLIFF representation in a file.  Its identifier is assumed to be the base part of the filename."	| fn id catalog |	fn := aPath asFilename.	id := fn tail readStream upTo: $..	catalog := self id: id.	catalog importXLIFFFile: fn.	^catalog</body><body package="ExtraCatalogs">id: anID	"Create a new catalog with identifier anID."	^self new id: anID</body><body package="ExtraCatalogs">new	^super new initialize</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog class</class-id> <category>accessing</category><body package="ExtraCatalogs">lookUp: aUserMessage	"This is the main Visualworks API for looking up UserMessages."	^Registry lookUp: aUserMessage</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog class</class-id> <category>utility</category><body package="ExtraCatalogs">updateManagerAfter: aBlock	"Ensure that MessageCatalogManager is aware of any changes just made to the catalog registry."	^aBlock ensure: [MessageCatalogManager updateCatalogs]</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog class</class-id> <category>class initialization</category><body package="ExtraCatalogs">initialize	self initializeRegistry</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog class</class-id> <category>registry</category><body package="ExtraCatalogs">catalogsForLocale: aLocale	"Answer all of the catalogs registered with aLocale."	^Registry catalogsForLocale: aLocale</body><body package="ExtraCatalogs">flush	"Unregister all catalogs."	self updateManagerAfter: [Registry flush]</body><body package="ExtraCatalogs">registerCatalog: aCatalog forLocale: aLocale	"Register aCatalog with aLocale.  If another catalog with the same ID is already registered,	it is replaced by aCatalog."	self		updateManagerAfter: [Registry addCatalog: aCatalog forLocale: aLocale]</body></methods><methods><class-id>ExtraCatalogs.SimpleMessageCatalog class</class-id> <category>private</category><body package="ExtraCatalogs">catalogsDo: aBlock	^Registry activeCatalogs do: aBlock</body><body package="ExtraCatalogs">initializeRegistry	Registry := CatalogRegistry new</body></methods><methods><class-id>Kernel.UserMessage</class-id> <category>converting</category><body package="ExtraCatalogs">asTranslationUnit	"Convert the receiver into a TranslationUnit for inclusing in a SimpleMessageCatalog."	^(ExtraCatalogs.TranslationUnit		id: self key		untranslated: self defaultString		translated: self defaultString)		catalogID: self catalogID;		yourself</body></methods><initialize><class-id>ExtraCatalogs.SimpleMessageCatalog</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MessageCatalog</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class><class><name>UserMessage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultString key catalogID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class></st-source>