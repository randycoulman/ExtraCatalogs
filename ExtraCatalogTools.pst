<?xml version="1.0"?><st-source><!-- Name: ExtraCatalogToolsNotice: The MIT License (MIT)Copyright (c) 2013 Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copy ofthis software and associated documentation files (the "Software"), to deal inthe Software without restriction, including without limitation the rights touse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies ofthe Software, and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESSFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS ORCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHERIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR INCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: # ExtraCatalogsAlternative MessageCatalog for Visualworks Smalltalk that supportsXLIFF-format files.ExtraCatalogs is licensed under the MIT license.  See the Copyrighttab in the RB, the 'notice' property of this package, or the LICENSEfile on GitHub.ExtraCatalogs' primary home is the[Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).Check there for the latest version.  It is also on[GitHub](https://github.com/randycoulman/ExtraCatalogs).ExtraCatalogs is compatible with VW 7.7 and later.  If you find anyincompatibilities with VW7.7 or later, let me know (see below for contact information) or filean issue on GitHub.# ExtraCatalogsToolsExtraCatalogsTools provides a simple UserMessageExtractor classthat can extracts `UserMessage`s from a compiled method.ExtraCatalogsTools is intended to work alongside ExtraCatalogs, butis actually completely independent and can be used on its own.To use it, use the built-in facilities in Visualworks,iterate all of the methods in your application that might contain`UserMessage`s that need to be translated.One way to do this is to start with `SystemUtils>>allBehaviorsDo:` andfilter the results based on whether the class might contain`UserMessage`s that you care about.For each method:```tree := aCompiledMethod mclass parseTreeFor: aCompiledMethod selector.visitor := UserMessageExtractor new.[visitor visitNode: tree] on: InformationSignal    do: [:ex | "Found a UserMessage that couldn't be extracted"               ex resume].^visitor userMessages```## Understanding the CodeThe only class of interest is `UserMessageExtractor`.  Start from the class comment.# ContributingI'm happy to receive bug fixes and improvements to this package.  Ifyou'd like to contribute, please publish your changes as a "branch"(non-integer) version in the Public Store Repository and contact me asoutlined below to let me know.  I will merge your changes back intothe "trunk" as soon as I can review them.# CreditsExtraCatalogs was originally written by Travis Griggs, who hasgraciously allowed me to take over maintenance of this package.# Contact InformationIf you have any questions about this package and how to use it, feel free to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1663DbUsername: randyDbVersion: 8DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'Browser-Parser' ''))PackageName: ExtraCatalogToolsParcel: #('ExtraCatalogTools')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'Browser-Parser' #componentType #package))PrerequisiteParcels: #(#('Base VisualWorks' '') #('Browser-Parser' ''))PrintStringCache: (8,randy)Version: 8Date: 6:45:12 AM August 2, 2013 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 7.9.1 of October 18, 2012 on August 2, 2013 at 6:45:12 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>UserMessageExtractor</name><environment>Smalltalk</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userMessages nodeCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>ExtraCatalogTools</package></attributes></class><comment><class-id>UserMessageExtractor</class-id><body>UserMessageExtractor extracts UserMessages from compiled methods.It is an RBProgramNodeVisitor.  As such, it works on the parse tree of the method.To use it:tree := aCompiledMethod mclass parseTreeFor: aCompiledMethod selector.visitor := UserMessageExtractor new.[visitor visitNode: tree] on: InformationSignal    do: [:ex | "Found a UserMessage that couldn't be extracted"               ex resume].^visitor userMessagesThe extracted UserMessages can be obtained by sending #userMessages to the extractor.Whenever UserMessageExtractor encounters a UserMessage that it doesn'tknow how to extract, it raises an InformationSignal notification.  If you want to keep track of failed extractions, you can handle that signal as above, and thenjust resume.Any user message that is constructed from anything other than a literals cannotbe extracted by UserMessageExtractor. UserMessageExtractor handles the typical 	#userMessageID &lt;&lt; #catalogID &gt;&gt; 'Default string'pattern by maintaining a cache of program nodes.  When it sees the #&lt;&lt; send above,it will add a new UserMessage with an ID of #userMessageID and a catalogID of #catalogID.  When it then sees the #&gt;&gt; send, it will look up the original UserMessageand add the default string to it.Instance Variables	nodeCache	&lt;Dictionary&gt;	Cache of program nodes already seen.	userMessages	&lt;Collection&gt;	The extracted UserMessages.</body></comment><methods><class-id>UserMessageExtractor</class-id> <category>initialize-release</category><body package="ExtraCatalogTools">initialize	super initialize.	userMessages := Set new.	nodeCache := IdentityDictionary new</body></methods><methods><class-id>UserMessageExtractor</class-id> <category>accessing</category><body package="ExtraCatalogTools">userMessages	"Answers the extracted UserMessages."	^userMessages</body></methods><methods><class-id>UserMessageExtractor</class-id> <category>visitor-double dispatching</category><body package="ExtraCatalogTools">acceptLiteralArrayNode: aNode 	self extractFromLiteralArrayNode: aNode.	^super acceptLiteralArrayNode: aNode</body><body package="ExtraCatalogTools">acceptMessageNode: aMessageNode 	super acceptMessageNode: aMessageNode.	aMessageNode selector = #&gt;&gt; 		ifTrue: [^self extractFromToStringNode: aMessageNode].	aMessageNode selector = #&lt;&lt; 		ifTrue: [^self extractFromToCatalogNode: aMessageNode]</body></methods><methods><class-id>UserMessageExtractor</class-id> <category>private</category><body package="ExtraCatalogTools">extractFromLiteralArrayNode: aNode 	| first |	aNode contents isEmpty ifTrue: [^self].	first := aNode value first.	first isBindingReference ifFalse: [^self].	first ifDefinedDo: 			[:val | 			val == UserMessage 				ifTrue: [userMessages add: aNode value decodeAsLiteralArray]]</body><body package="ExtraCatalogTools">extractFromToCatalogNode: aMessageNode 	| recv arg catalog um |	arg := aMessageNode arguments first.	arg isLiteralNode ifFalse: [^InformationSignal raiseRequest].	catalog := arg value.	recv := aMessageNode receiver.	recv isLiteralNode 		ifTrue: 			[um := UserMessage 						defaultString: nil						key: recv value						catalogID: catalog.			nodeCache at: aMessageNode put: um.			^userMessages add: um].	(nodeCache includesKey: recv) 		ifTrue: 			[um := nodeCache removeKey: recv.			userMessages remove: um.			um catalogID: catalog.			^userMessages add: um].	^InformationSignal raiseRequest</body><body package="ExtraCatalogTools">extractFromToStringNode: aMessageNode 	| recv arg um defaultString |	arg := aMessageNode arguments first.	arg isLiteralNode ifFalse: [^InformationSignal raiseRequest].	defaultString := arg value.	recv := aMessageNode receiver.	recv isLiteralNode 		ifTrue: 			[um := UserMessage defaultString: defaultString key: recv value.			nodeCache at: aMessageNode put: um.			^userMessages add: um].	(nodeCache includesKey: recv) 		ifTrue: 			[um := nodeCache removeKey: recv.			userMessages remove: um.			um defaultString: defaultString.			^userMessages add: um].	^InformationSignal raiseRequest</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class></st-source>